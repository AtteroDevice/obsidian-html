<script src="//unpkg.com/force-graph"></script>
<script src="//unpkg.com/d3-force"></script>
<script>
    //onNodeHover
    function grapher(args) {
        let current_node = args.current_node_id;
        let centered = false;

        //fetch('{html_url_prefix}/obs.html/data/graph.json').then(res => res.json()).then(data => {
        fetch(args.data).then(res => res.json()).then(data => {
            const Graph = ForceGraph()
            (args.graph_container)
            .graphData(data)
            .width(args.width)
            .height(400)
            .backgroundColor('#f4f4f4')
            .nodeLabel('id')
            .d3Force("charge", d3.forceManyBody().strength(-30))
            .nodeColor(() => {return '#546bdd'})
            .nodeCanvasObjectMode(() => 'after')
            .nodeCanvasObject((node, ctx, globalScale) => {
                // draw text only for nodes connected to the current node
                let isConnected = false;
                node.links.forEach(link => {
                    if (link == current_node){
                        isConnected = true;
                    }
                })
                // draw text
                if (isConnected){
                    const label = node.id;
                    const fontSize = 11 / globalScale;
                    ctx.font = `${fontSize}px Sans-Serif`;
                    const textWidth = ctx.measureText(label).width;                
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#000000';
                    ctx.fillText(label, node.x, node.y+8);
                }                    
                
                // color only main node
                if (node.id != args.current_node_id){
                    return
                }

                // Center/zoom on node
                if (centered == false){
                    Graph.centerAt(node.x, node.y, 1000);
                    Graph.zoom(2, 500);
                }
                centered = true;


                // color node
                ctx.beginPath();
                ctx.arc(node.x, node.y, 4+1, 0, 2 * Math.PI);
                ctx.fillStyle = '#f7be49';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(node.x, node.y, 4, 0, 2 * Math.PI);
                ctx.fillStyle = '#546bdd';
                ctx.fill();                

            })            
            .linkColor(link => {
                if (link.source.id == args.current_node_id){
                    return '#f7be49'
                }
                if (link.target.id == args.current_node_id){
                    return '#f7be49'
                }
                return '#dadada'
            })
            .linkDirectionalParticles("value")
            .linkDirectionalParticleSpeed(0.010)
            .linkDirectionalParticleWidth(link => {
                if (link.source.id == args.current_node_id || link.target.id == args.current_node_id){
                    return 4.0
                }
                return 0
            })
            .onNodeClick(node => {
                graph_open_link(node.url, args)()
            });
        });
    }
</script>