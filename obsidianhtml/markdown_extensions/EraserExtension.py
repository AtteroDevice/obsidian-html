"""
Eraser Extension for Python-Markdown
========================================

Removes all code between the opening sequence and the closing sequence.
Lines that contain either the opening or closing sequence are removed as well.

Matches in code blocks are ignored. Thus, having an opening or closing sequence like "``` abc"
will not work.

The sequences should be regex values that contain a capturing group.
Make them as specific as possible, for example, for this text:

    %% Zoottelkeeper: Beginning of the autogenerated index file list  %%
    -  [[Buglog/test/File links in dirtree note do not work|File links in dirtree note do not work]]
    -  [[Buglog/test/Spaces in front of headers allowed by Obsidian but not by ObsidianHtml|Spaces in front of headers allowed by Obsidian but not by ObsidianHtml]]
    %% Zoottelkeeper: End of the autogenerated index file list  %%

We want to remove the wrappers.

Opening sequence:
- Start at beginning of the line: ^
- These chars: %% Zoottelkeeper: "%% Zoottelkeeper: "
--> r'(^%% Zoottelkeeper: )'

Closing sequence:
- From start of line we expect one or more of any chars: r'^.+'
- Then one or more spaces ending in %%  r' +%%'
- Then optionally any number of spaces until the end of the line: r' *$'
--> r'(^.+ +%% *$)'

Note that the text is parsed line for line.

This extension works best when you have distinct opening and closing tags.
It is possible though to cut out blocks like so:

    This is text
    %%
    this will be removed, inc the percentage signs
    %%
    This is text

By setting the homogenous setting to True. 
Note that this will cause the following line to turn on erase mode, and never turn it off:

    This is text 
    %% this will be removed, inc the percentage signs %%
    This is text (will also be removed by mistake)

"""

from markdown.extensions import Extension
from markdown.preprocessors import Preprocessor

import regex as re
import string



# ------------------ The Markdown Extension -------------------------------

class EraserExtension(Extension):
    """ Remove blocks enclosed by certain characters, such as %%%. """
    def __init__(self, **kwargs):
        self.config = {
            'opening_sequence' : ['not_set', 'Regex value to start erasing. Entire line will be removed'],
            'closing_sequence' : ['not_set', 'Regex value to stop erasing. Current line will still be removed'], 
            'homogenous' :       [False, 'Whether the opening sequence will also function as closing sequence'], 
            'verbose' :          [False, 'Whether to print output']
        }
        super(EraserExtension, self).__init__(**kwargs)

    def extendMarkdown(self, md):
        """ Add EraserExtension to Markdown instance. """
        # Insert a preprocessor before ReferencePreprocessor
        md.preprocessors.register(EraserPreprocessor(self, md), 'eraser', 35)
        md.registerExtension(self)

def makeExtension(**kwargs):  # pragma: no cover
    return EraserExtension(**kwargs)

class EraserPreprocessor(Preprocessor):
    def __init__(self, extension, md=None):
        self.md = md
        self.extension = extension
        self.verbose = self.extension.getConfig('verbose')

    def verbose_print(self, msg):
        if self.verbose:
            print(f"eraser extension: {msg}")

    def run(self, lines):
        opening_regex = self.extension.getConfig('opening_sequence')
        closing_regex = self.extension.getConfig('closing_sequence')
        homogenous    = self.extension.getConfig('homogenous')

        code_block_open_regex = r'(^ *```)'
        code_block_close_regex = r'(^ *``` *$)'

        if opening_regex == 'not_set':
            raise Exception('Extension config setting opening_regex was not set')
        if closing_regex == 'not_set':
            raise Exception('Extension config setting closing_regex was not set')

        mode = 'read'

        new_lines = []
        for line in lines: 
            stick_code_block = False
            stick_erase_begin = False

            if mode == 'code_block':
                code_block_end = re.match(code_block_close_regex, line) 
                if code_block_end:
                    mode = 'read'
                    stick_code_block = True
                    self.verbose_print(f'mode: {mode}')

            if mode == 'read':
                if not stick_code_block:
                    code_block_start = re.match(code_block_open_regex, line)
                    if code_block_start:
                        mode = 'code_block'
                        self.verbose_print(f'mode: {mode}')

                match_start = re.match(opening_regex, line)
                if match_start:
                    mode = 'erase'
                    stick_erase_begin = True
                    self.verbose_print(f'mode: {mode}')

            if mode in ['read', 'code_block']:
                new_lines.append(line)
            else:
                self.verbose_print(f'erase: "{line}"')

            if mode == 'erase':
                # don't end erase mode on the same line where we started erase mode if the opening and closing sequences are the same
                if not (homogenous and stick_erase_begin):
                    match_end = re.match(closing_regex, line)
                    match_end = match_end or (homogenous and re.match(opening_regex, line))
                    if match_end:
                        mode = 'read'
                        self.verbose_print(f'mode: {mode}')

        return new_lines

